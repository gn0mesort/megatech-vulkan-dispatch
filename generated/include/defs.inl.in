##
## @file defs.inl.in
## @brief Vulkan Dispatch Definitions Template
## @author Alexander Rothman <gnomesort@megate.ch>
## @date 2024
## @copyright AGPL-3.0-or-later
## @cond
<%!
  import sys
  from argparse import ArgumentParser
%>\
<%
  parser = ArgumentParser(prog="defs.inl.in", add_help=False, exit_on_error=False, prefix_chars="@")
  parser.add_argument("@help", "@h", action="help", help="Display this help message and exit.")
  parser.add_argument("@generate-defines", action="store_true", default=False,
                      help="When enabled, generate \"#define\"s for enabled Vulkan APIs and extensions. These are "
                           "always defined to 1.")
try:
    args = parser.parse_args(arguments)
  except Exception as err:
    print(err, file=sys.stderr)
    parser.print_help(file=sys.stderr)
    return STOP_RENDERING
%>\
/**
 * @file defs.inl
 * @brief Vulkan Dispatch Definitions Inline File
 * @author Generated
 * @date ${f"{buildtime:%B} {buildtime.day:02}, {buildtime.year}"}
 */
#ifndef MEGATECH_VULKAN_DISPATCH_DEFS_INL
#define MEGATECH_VULKAN_DISPATCH_DEFS_INL
#include <cinttypes>

#include <string>

/**
 * @def MEGATECH_VULKAN_DISPATCH_BUILD_DATE
 * @brief The date on which this file was generated in the format YYYYMMDD.
 * @details All times are UTC.
 */
#define MEGATECH_VULKAN_DISPATCH_BUILD_DATE (${f"{buildtime.year}{buildtime.month:02}{buildtime.day:02}"}ULL)
/**
 * @def MEGATECH_VULKAN_DISPATCH_BUILD_TIME
 * @brief The time at which this file was generated in the format HHMMSS.
 * @details All times are UTC.
 */
#define MEGATECH_VULKAN_DISPATCH_BUILD_TIME (${f"{buildtime.hour}{buildtime.minute:02}{buildtime.second:02}"}ULL)
% if args.generate_defines:
% for name in specification.apis():
<% api = specification.apis()[name] %>\
% if api.enabled():
/**
 * @def MEGATECH_VULKAN_API_${api.name().replace("VK_", "").upper()}_ENABLED
 * @brief Indicates that "${api.name()}" was enabled during generation.
 */
#define MEGATECH_VULKAN_API_${api.name().replace("VK_", "").upper()}_ENABLED (1)
% endif
% endfor
% for name in specification.extensions():
<% extension = specification.extensions()[name] %>\
% if extension.enabled():
/**
 * @def MEGATECH_VULKAN_DISPATCH_${extension.name().replace("VK_", "").upper()}_ENABLED
 * @brief Indicates that "${extension.name()}" was enabled during generation.
 */
#define MEGATECH_VULKAN_DISPATCH_${extension.name().replace("VK_", "").upper()}_ENABLED (1)
% endif
% endfor
% endif
/**
 * @def MEGATECH_VULKAN_DISPATCH_DEFINE_HANDLE
 * @brief Define a dispatchable Vulkan handle type.
 * @details This is equivalent to the VK_DEFINE_HANDLE macro.
 * @param object The name of the object to define.
 */
#define MEGATECH_VULKAN_DISPATCH_DEFINE_HANDLE(object) ${"\\"}
  struct object##_T; ${"\\"}
  typedef object##_T* object

/// @cond
#if defined(_WIN32)
  #define MEGATECH_VULKAN_DISPATCH_API_ATTR_PRIV
  #define MEGATECH_VULKAN_DISPATCH_API_CALL_PRIV __stdcall
  #define MEGATECH_VULKAN_DISPATCH_API_PTR_PRIV MEGATECH_VULKAN_DISPATCH_API_CALL
#elif defined(__ANDROID__) && defined(__ARM_ARCH) && __ARM_ARCH < 7
  #error "Vulkan is not supported for the 'armeabi' NDK ABI"
#elif defined(__ANDROID__) && defined(__ARM_ARCH) && __ARM_ARCH >= 7 && defined(__ARM_32BIT_STATE)
  #define MEGATECH_VULKAN_DISPATCH_API_ATTR_PRIV __attribute__((pcs("aapcs-vfp")))
  #define MEGATECH_VULKAN_DISPATCH_API_CALL_PRIV
  #define MEGATECH_VULKAN_DISPATCH_API_PTR_PRIV MEGATECH_VULKAN_DISPATCH_API_ATTR
#else
  #define MEGATECH_VULKAN_DISPATCH_API_ATTR_PRIV
  #define MEGATECH_VULKAN_DISPATCH_API_CALL_PRIV
  #define MEGATECH_VULKAN_DISPATCH_API_PTR_PRIV
#endif
/// @endcond

/**
 * @def MEGATECH_VULKAN_DISPATCH_API_CALL
 * @brief The calling convention used for the Vulkan API.
 * @details This can be overridden at the client's choice. This **MUST** be equivalent to VKAPI_CALL.
 */
#ifndef MEGATECH_VULKAN_DISPATCH_API_CALL
  #define MEGATECH_VULKAN_DISPATCH_API_CALL MEGATECH_VULKAN_DISPATCH_API_CALL_PRIV
#endif
/**
 * @def MEGATECH_VULKAN_DISPATCH_API_ATTR
 * @brief The function attribute used for the Vulkan API.
 * @details This can be overridden at the client's choice. This **MUST** be equivalent to VKAPI_ATTR.
 */
#ifndef MEGATECH_VULKAN_DISPATCH_API_ATTR
  #define MEGATECH_VULKAN_DISPATCH_API_ATTR MEGATECH_VULKAN_DISPATCH_API_ATTR_PRIV
#endif
/**
 * @def MEGATECH_VULKAN_DISPATCH_API_PTR
 * @brief The function pointer attribute used for the Vulkan API.
 * @details This can be overridden at the client's choice. This **MUST** be equivalent to VKAPI_PTR.
 */
#ifndef MEGATECH_VULKAN_DISPATCH_API_PTR
  #define MEGATECH_VULKAN_DISPATCH_API_PTR MEGATECH_VULKAN_DISPATCH_API_PTR_PRIV
#endif

/// @cond
#define MEGATECH_VULKAN_DISPATCH_GLOBAL_COMMAND_LIST ${"\\"}
<% count = 0 %>\
% for cmd in sorted(commands.global_commands()):
  MEGATECH_VULKAN_DISPATCH_COMMAND(${cmd.name()}) ${"\\" if count < len(commands.global_commands()) - 1 else ""}
<% count += 1 %>\
% endfor

#define MEGATECH_VULKAN_DISPATCH_INSTANCE_COMMAND_LIST ${"\\"}
<% count = 0 %>\
% for cmd in sorted(commands.instance_commands()):
  MEGATECH_VULKAN_DISPATCH_COMMAND(${cmd.name()}) ${"\\" if count < len(commands.instance_commands()) - 1 else "" }
<% count += 1 %>\
% endfor

#define MEGATECH_VULKAN_DISPATCH_DEVICE_COMMAND_LIST ${"\\"}
<% count = 0 %>\
% for cmd in sorted(commands.device_commands()):
  MEGATECH_VULKAN_DISPATCH_COMMAND(${cmd.name()}) ${"\\" if count < len(commands.device_commands()) - 1 else ""}
<% count += 1 %>\
% endfor
/// @endcond

extern "C" {

/**
 * @typedef VkInstance
 * @brief A type equivalent to the VkInstance handle as defined by Vulkan.
 * @see https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html
 */
MEGATECH_VULKAN_DISPATCH_DEFINE_HANDLE(VkInstance);
/**
 * @typedef VkDevice
 * @brief A type equivalent to the VkDevice handle as defined by Vulkan.
 * @see https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDevice.html
 */
MEGATECH_VULKAN_DISPATCH_DEFINE_HANDLE(VkDevice);
/**
 * @brief A generic Vulkan function pointer.
 * @details Values of this type **MUST** be reinterpreted to the correct function pointer type before being called.
 * @see https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/PFN_vkVoidFunction.html
 */
typedef void (MEGATECH_VULKAN_DISPATCH_API_PTR *PFN_vkVoidFunction)(void);
/**
 * @brief A pointer to a Vulkan instance-level loader function.
 * @see https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetInstanceProcAddr.html
 */
typedef PFN_vkVoidFunction (MEGATECH_VULKAN_DISPATCH_API_PTR *PFN_vkGetInstanceProcAddr)(VkInstance, const char*);
/**
 * @brief A pointer to a Vulkan device-level loader function.
 * @see https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceProcAddr.html
 */
typedef PFN_vkVoidFunction (MEGATECH_VULKAN_DISPATCH_API_PTR *PFN_vkGetDeviceProcAddr)(VkDevice, const char*);

}

/// @cond INTERNAL
namespace megatech::vulkan::dispatch::internal::base {

/**
 * @def MEGATECH_VULKAN_DISPATCH_INTERNAL_BASE_FNV1A_CSTR
 * @brief Define a `consteval` FNV1a hash function.
 * @details FNV1a is a simple, insecure, hash function. For this use case, I think it is a good solution. These
 *          functions are always resolved to a value at compile-time so, even if you have an insane case where this
 *          library is being used by a web server, I don't think it could realistically be used to attack the library.
 * @param result_type The type of the result (and, therefore, the length of the hash). For example, std::uint32_t, or
 *                    std::uint64_t.
 * @param id A unique id value to be appended to the function's name. This should probably be the bit length of the
 *           hash.
 * @param offset The FNV1a offset. This should be computed for the width of the hash.
 * @param prime The FNV1a prime. This should be computed for the width of the hash.
 */
#define MEGATECH_VULKAN_DISPATCH_INTERNAL_BASE_FNV1A_CSTR(result_type, id, offset, prime) ${"\\"}
  consteval result_type fnv1a_cstr_##id(const char* str) { ${"\\"}
    auto hash = static_cast<result_type>((offset)); ${"\\"}
    while (*str) ${"\\"}
    { ${"\\"}
      hash ^= *str; ${"\\"}
      hash *= static_cast<result_type>((prime)); ${"\\"}
      ++str; ${"\\"}
    } ${"\\"}
    return hash; ${"\\"}
  } ${"\\"}
  static_assert(true)

/**
 * @brief Compute a 32-bit FNV1a hash of a C-style string.
 * @param str A NUL (``'${"\\"}0'``) terminated byte string.
 * @return An unsigned 32-bit integer value.
 */
MEGATECH_VULKAN_DISPATCH_INTERNAL_BASE_FNV1A_CSTR(std::uint32_t, 32, 0x811c9dc5, 0x01000193);
/**
 * @brief Compute a 64-bit FNV1a hash of a C-style string.
 * @param str A NUL (``'${"\\"}0'``) terminated byte string.
 * @return An unsigned 64-bit integer value.
 */
MEGATECH_VULKAN_DISPATCH_INTERNAL_BASE_FNV1A_CSTR(std::uint64_t, 64, 0xcbf29ce484222325, 0x100000001b3);
/**
 * @brief Compute an FNV1a hash of a C-style string.
 * @details Unlike the bit width specific variants of this function, this variant will compute a hash based on the
 *          width of `std::size_t`. By definition in C++20, the width of `std::size_t` cannot be less than 16.
 *
 *          There are 3 options for how this function works. First if `sizeof(std::size_t)` is greater than or equal to
 *          `sizeof(std::uint64_t)`, the 64-bit variant is invoked. If that fails but `sizeof(std::size_t)` is
 *          greater than or equal to `sizeof(std::uint32_t)`, the 32-bit variant is invoked. Finally if
 *          `sizeof(std::size_t)` is less than `sizeof(std::uint32_t)`, the 32-bit variant is invoked and then folded
 *          into a 16-bit value.
 *
 *          In any case, this function is always resolved to a value at compile-time.
 * @param str A NUL (``'${"\\"}0'``) terminated byte string.
 * @return A `std::size_t` value containing a 64-bit, 32-bit, or 16-bit hash value as appropriate.
 * @see https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
 */
consteval std::size_t fnv1a_cstr(const char* str) {
  static_assert(sizeof(std::size_t) >= sizeof(std::uint16_t));
  if constexpr (sizeof(std::size_t) >= sizeof(std::uint64_t))
  {
    return fnv1a_cstr_64(str);
  }
  else if (sizeof(std::size_t) >= sizeof(std::uint32_t))
  {
    return fnv1a_cstr_32(str);
  }
  else if (sizeof(std::size_t) >= sizeof(std::uint16_t))
  {
    const auto hash = fnv1a_cstr_32(str);
    return static_cast<std::uint16_t>((hash >> 16) ^ (hash & 0xff'ff));
  }
}

}
/// @endcond

namespace megatech::vulkan::dispatch {

  /**
   * @brief A class representing errors generated during dispatch table construction.
   */
  class error final : public std::exception {
  private:
    std::string m_what{ };
  public:
    /**
     * @brief Construct an error.
     * @param what An error message.
     */
    explicit error(const std::string& what);
    /**
     * @brief Copy an error.
     * @param other The error to copy.
     */
    error(const error& other) = default;
    /**
     * @brief Move an error.
     * @param other The error to move.
     */
    error(error&& other) = default;
    /**
     * @brief Destroy an error.
     */
    ~error() noexcept = default;
    /**
     * @brief Copy-assign an error.
     * @param rhs The error to copy.
     * @return A reference to the copied-to error.
     */
    error& operator=(const error& rhs) = default;
    /**
     * @brief Move-assign an error.
     * @param rhs The error to move.
     * @return A reference to the moved-to error.
     */
    error& operator=(error&& rhs) = default;
    /**
     * @brief Retrieve the error's message.
     * @return A null-terminated string indicating the cause of the error.
     */
    const char* what() const noexcept override;
  };

}

#endif
## @endcond
