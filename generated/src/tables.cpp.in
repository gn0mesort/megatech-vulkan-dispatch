##
## @file tables.cpp.in
## @brief Vulkan Dispatch Table Template Source
## @author Alexander Rothman <gnomesort@megate.ch>
## @date 2024
## @copyright AGPL-3.0-or-later
## @cond
<%!
  import sys
  from argparse import ArgumentParser
%>\
<%
  parser = ArgumentParser(prog="tables.cpp.in", add_help=False, exit_on_error=False, prefix_chars="@")
  parser.add_argument("@help", "@h", action="help", help="Display this help message and exit.")
  try:
    args = parser.parse_args(arguments)
  except Exception as err:
    print(err, file=sys.stderr)
    parser.print_help(file=sys.stderr)
    return STOP_RENDERING
%>\
/**
 * @file table.cpp
 * @brief Vulkan Dispatch Tables
 * @author Generated
 * @date 2024
 */
#include "megatech/vulkan/dispatch/tables.hpp"

#define G(cl, ctx, cmd) (m_pfns[static_cast<std::size_t>(megatech::vulkan::dispatch::global::command::cmd)] = (cl)((ctx), (#cmd)))
#define I(cl, ctx, cmd) (m_pfns[static_cast<std::size_t>(megatech::vulkan::dispatch::instance::command::cmd)] = (cl)((ctx), (#cmd)))
#define D(cl, ctx, cmd) (m_pfns[static_cast<std::size_t>(megatech::vulkan::dispatch::device::command::cmd)] = (cl)((ctx), (#cmd)))

namespace megatech::vulkan::dispatch {

  error::error(const std::string& what) : m_what{ what } { }

  const char* error::what() const noexcept {
    return m_what.data();
  }

namespace global {

  table::table(const PFN_vkGetInstanceProcAddr global) {
    if (!global)
    {
      throw error{ "The global loader command, \"vkGetInstanceProcAddr\", cannot be null." };
    }
% for cmd in sorted(commands.global_commands()):
% if cmd.name() != "vkGetInstanceProcAddr":
    G(global, nullptr, ${cmd.name()});
% endif
% endfor
    m_pfns[static_cast<std::size_t>(command::vkGetInstanceProcAddr)] = reinterpret_cast<PFN_vkVoidFunction>(global);
  }

}

namespace instance {

  table::table(megatech::vulkan::dispatch::global::table& global, const VkInstance instance) {
    using gcmd = megatech::vulkan::dispatch::global::command;
    if (!instance)
    {
      throw error{ "The \"VkInstance\" handle cannot be null." };
    }
    const auto cl = *reinterpret_cast<const PFN_vkGetInstanceProcAddr*>(global.get(gcmd::vkGetInstanceProcAddr));
% for cmd in sorted(commands.instance_commands()):
    I(cl, instance, ${cmd.name()});
% endfor
    m_instance = instance;
  }

  VkInstance table::instance() const {
    return m_instance;
  }

}

namespace device {

  table::table(megatech::vulkan::dispatch::global::table& global,
               megatech::vulkan::dispatch::instance::table& instance, const VkDevice device) {
    using gcmd = megatech::vulkan::dispatch::global::command;
    if (!device)
    {
      throw error{ "The \"VkDevice\" handle cannot be null." };
    }
    const auto gipa = *reinterpret_cast<const PFN_vkGetInstanceProcAddr*>(global.get(gcmd::vkGetInstanceProcAddr));
    const auto igdpa = reinterpret_cast<PFN_vkGetDeviceProcAddr>(gipa(instance.instance(), "vkGetDeviceProcAddr"));
    const auto cl = reinterpret_cast<PFN_vkGetDeviceProcAddr>(igdpa(device, "vkGetDeviceProcAddr"));
% for cmd in sorted(commands.device_commands()):
% if cmd.name() != "vkGetDeviceProcAddr":
    D(cl, device, ${cmd.name()});
% endif
% endfor
    m_pfns[static_cast<std::size_t>(command::vkGetDeviceProcAddr)] = reinterpret_cast<PFN_vkVoidFunction>(cl);
    m_device = device;
  }

  VkDevice table::device() const {
    return m_device;
  }

}

}
## @endcond
